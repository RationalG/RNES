/* Generated by Nim Compiler v0.10.2 */
/*   (c) 2014 Andreas Rumpf */
/* The generated code is subject to the original license. */
/* Compiled for: Windows, amd64, gcc */
/* Command for C compiler:
   gcc.exe -c  -w  -IC:\Nim\lib -o c:\users\simon\rationalnes_\rnes\src\nimcache\rom.o c:\users\simon\rationalnes_\rnes\src\nimcache\rom.c */
#define NIM_INTBITS 64
#include "nimbase.h"

#include <string.h>

#include <stdio.h>
typedef struct romobj137027 romobj137027;
typedef struct TNimObject TNimObject;
typedef struct TNimType TNimType;
typedef struct TNimNode TNimNode;
typedef struct TY131128 TY131128;
typedef struct TGenericSeq TGenericSeq;
typedef struct slice86066 slice86066;
typedef struct headerobj137029 headerobj137029;
typedef struct NimStringDesc NimStringDesc;
typedef N_NIMCALL_PTR(void, TY3089) (void* p, NI op);
typedef N_NIMCALL_PTR(void*, TY3094) (void* p);
struct  TNimType  {
NI size;
NU8 kind;
NU8 flags;
TNimType* base;
TNimNode* node;
void* finalizer;
TY3089 marker;
TY3094 deepcopy;
};
struct  TNimObject  {
TNimType* m_type;
};
typedef NIM_CHAR TY137030[16];
struct  TGenericSeq  {
NI len;
NI reserved;
};
struct  romobj137027  {
  TNimObject Sup;
TY137030 Header;
TY131128* Prgbytes;
TY131128* Chrbytes;
};
struct  TNimNode  {
NU8 kind;
NI offset;
TNimType* typ;
NCSTRING name;
NI len;
TNimNode** sons;
};
struct  slice86066  {
NI A;
NI B;
};
struct  NimStringDesc  {
  TGenericSeq Sup;
NIM_CHAR data[SEQ_DECL_SIZE];
};
struct  headerobj137029  {
  TNimObject Sup;
NimStringDesc* Signature;
NI Prgsize;
NI Chrsize;
NU8 Mmbyte;
NI Mapperbits;
NI Mirrorbits;
};
struct TY131128 {
  TGenericSeq Sup;
  NIM_CHAR data[SEQ_DECL_SIZE];
};
N_NIMCALL(TY131128*, HEX5BHEX5D_137072)(TY137030 a_137079, slice86066 x_137084);
N_NIMCALL(void, loadines_137051)(FILE* romfile, romobj137027* Result);
N_NIMCALL(NI, readbuffer_13027)(FILE* f, void* buffer, NI len);
N_NIMCALL(NimStringDesc*, seqtostring_131281)(TY131128* seq);
static N_INLINE(slice86066, HEX2EHEX2E_93099)(NI a_93103, NI b_93105);
static N_INLINE(void, nimFrame)(TFrame* s);
N_NOINLINE(void, stackoverflow_18801)(void);
static N_INLINE(void, popFrame)(void);
N_NIMCALL(NI, mulInt)(NI a, NI b);
N_NIMCALL(NimStringDesc*, nimIntToStr)(NI x);
N_NIMCALL(TY131128*, newseq_131123)(NI len_131127);
N_NOINLINE(void, raiseIndexError)(void);
N_NIMCALL(void, genericAssign)(void* dest, void* src, TNimType* mt);
STRING_LITERAL(TMP318, "iNES format recognized !!!", 26);
STRING_LITERAL(TMP319, "PRG size : ", 11);
STRING_LITERAL(TMP320, " x 16kb pages : ", 16);
STRING_LITERAL(TMP321, "CHR size : ", 11);
STRING_LITERAL(TMP322, " x 8kb pages :  ", 16);
STRING_LITERAL(TMP323, "Error : unknown ROM format", 26);
romobj137027 nesrom_137046;
extern TNimType NTI3211; /* RootObj */
TNimType NTI137027; /* ROMObj */
extern TNimType NTI147; /* char */
TNimType NTI137030; /* array[0..15, char] */
extern TNimType NTI131128; /* seq[char] */
TNimType NTI137029; /* HeaderObj */
extern TNimType NTI149; /* string */
extern TNimType NTI108; /* int */
extern TNimType NTI3205; /* byte */
extern TFrame* frameptr_16242;

static N_INLINE(void, nimFrame)(TFrame* s) {
	NI LOC1;
	LOC1 = 0;
	{
		if (!(frameptr_16242 == NIM_NIL)) goto LA4;
		LOC1 = 0;
	}
	goto LA2;
	LA4: ;
	{
		LOC1 = ((NI) ((NI16)((*frameptr_16242).calldepth + ((NI16) 1))));
	}
	LA2: ;
	(*s).calldepth = ((NI16) (LOC1));
	(*s).prev = frameptr_16242;
	frameptr_16242 = s;
	{
		if (!((*s).calldepth == ((NI16) 2000))) goto LA9;
		stackoverflow_18801();
	}
	LA9: ;
}

static N_INLINE(void, popFrame)(void) {
	frameptr_16242 = (*frameptr_16242).prev;
}

static N_INLINE(slice86066, HEX2EHEX2E_93099)(NI a_93103, NI b_93105) {
	slice86066 result;
	nimfr("..", "system.nim")
	memset((void*)(&result), 0, sizeof(result));
	nimln(226, "system.nim");
	result.A = a_93103;
	nimln(227, "system.nim");
	result.B = b_93105;
	popFrame();
	return result;
}

N_NIMCALL(void, loadines_137051)(FILE* romfile, romobj137027* Result) {
	romobj137027 r;
	headerobj137029 h;
	NI LOC1;
	slice86066 LOC2;
	TY131128* LOC3;
	NI TMP316;
	NI TMP317;
	NI LOC14;
	NI LOC15;
	nimfr("loadINes", "rom.nim")
	memset((void*)(&r), 0, sizeof(r));
	r.Sup.m_type = (&NTI137027);
	memset((void*)(&h), 0, sizeof(h));
	h.Sup.m_type = (&NTI137029);
	nimln(30, "rom.nim");
	nimln(30, "rom.nim");
	LOC1 = 0;
	LOC1 = readbuffer_13027(romfile, ((void*) (r.Header)), 16);
	nimln(32, "rom.nim");
	nimln(32, "rom.nim");
	nimln(32, "rom.nim");
	LOC2 = HEX2EHEX2E_93099(0, 3);
	LOC3 = 0;
	LOC3 = HEX5BHEX5D_137072(r.Header, LOC2);
	h.Signature = seqtostring_131281(LOC3);
	nimln(33, "rom.nim");
	nimln(33, "rom.nim");
	TMP316 = mulInt(((NI) (((NU8)(r.Header[(4)- 0])))), 16384);
	h.Prgsize = (NI64)(TMP316);
	nimln(34, "rom.nim");
	nimln(34, "rom.nim");
	TMP317 = mulInt(((NI) (((NU8)(r.Header[(5)- 0])))), 8192);
	h.Chrsize = (NI64)(TMP317);
	nimln(35, "rom.nim");
	h.Mmbyte = ((NU8) (((NU8)(r.Header[(6)- 0]))));
	nimln(36, "rom.nim");
	nimln(36, "rom.nim");
	nimln(36, "rom.nim");
	h.Mapperbits = ((NI) ((NI)((NI)((NU64)(((NI) (h.Mmbyte))) >> (NU64)(4)) & 15)));
	nimln(37, "rom.nim");
	nimln(37, "rom.nim");
	h.Mirrorbits = ((NI) ((NI)(((NI) (h.Mmbyte)) & 15)));
	nimln(39, "rom.nim");
	{
		int LOC6;
		NimStringDesc* LOC9;
		NimStringDesc* LOC10;
		NimStringDesc* LOC11;
		NimStringDesc* LOC12;
		nimln(39, "rom.nim");
		nimln(39, "rom.nim");
		LOC6 = 0;
		LOC6 = memcmp(h.Signature->data, "NES\032", 4);
		if (!(LOC6 == ((NI32) 0))) goto LA7;
		nimln(40, "rom.nim");
		nimln(40, "rom.nim");
		printf("%s\015\012", (((NimStringDesc*) &TMP318))->data);
		nimln(41, "rom.nim");
		nimln(41, "rom.nim");
		nimln(41, "rom.nim");
		nimln(41, "rom.nim");
		LOC9 = 0;
		LOC9 = nimIntToStr((NI)((NU64)(h.Prgsize) / (NU64)(16384)));
		nimln(41, "rom.nim");
		nimln(41, "rom.nim");
		LOC10 = 0;
		LOC10 = nimIntToStr(h.Prgsize);
		printf("%s%s%s%s\015\012", (((NimStringDesc*) &TMP319))->data, (LOC9)->data, (((NimStringDesc*) &TMP320))->data, (LOC10)->data);
		nimln(42, "rom.nim");
		nimln(42, "rom.nim");
		nimln(42, "rom.nim");
		nimln(42, "rom.nim");
		LOC11 = 0;
		LOC11 = nimIntToStr((NI)((NU64)(h.Chrsize) / (NU64)(8192)));
		nimln(42, "rom.nim");
		nimln(42, "rom.nim");
		LOC12 = 0;
		LOC12 = nimIntToStr(h.Chrsize);
		printf("%s%s%s%s\015\012", (((NimStringDesc*) &TMP321))->data, (LOC11)->data, (((NimStringDesc*) &TMP322))->data, (LOC12)->data);
	}
	goto LA4;
	LA7: ;
	{
		nimln(44, "rom.nim");
		nimln(44, "rom.nim");
		printf("%s\015\012", (((NimStringDesc*) &TMP323))->data);
		nimln(45, "rom.nim");
		goto BeforeRet;
	}
	LA4: ;
	nimln(47, "rom.nim");
	r.Prgbytes = newseq_131123(h.Prgsize);
	nimln(48, "rom.nim");
	r.Chrbytes = newseq_131123(h.Chrsize);
	nimln(50, "rom.nim");
	nimln(50, "rom.nim");
	if ((NU)(0) >= (NU)(r.Prgbytes->Sup.len)) raiseIndexError();
	LOC14 = 0;
	LOC14 = readbuffer_13027(romfile, ((void*) ((&r.Prgbytes->data[0]))), h.Prgsize);
	nimln(51, "rom.nim");
	nimln(51, "rom.nim");
	if ((NU)(0) >= (NU)(r.Chrbytes->Sup.len)) raiseIndexError();
	LOC15 = 0;
	LOC15 = readbuffer_13027(romfile, ((void*) ((&r.Chrbytes->data[0]))), h.Chrsize);
	nimln(53, "rom.nim");
	nimln(53, "rom.nim");
	genericAssign((void*)Result, (void*)(&r), (&NTI137027));
	goto BeforeRet;
	BeforeRet: ;
	popFrame();
}
NIM_EXTERNC N_NOINLINE(void, HEX00_romInit)(void) {
	nimfr("rom", "rom.nim")
	nesrom_137046.Sup.m_type = (&NTI137027);
	popFrame();
}

NIM_EXTERNC N_NOINLINE(void, HEX00_romDatInit)(void) {
static TNimNode* TMP311[3];
static TNimNode* TMP315[6];
static TNimNode TMP309[11];
NTI137027.size = sizeof(romobj137027);
NTI137027.kind = 17;
NTI137027.base = (&NTI3211);
TMP311[0] = &TMP309[1];
NTI137030.size = sizeof(TY137030);
NTI137030.kind = 16;
NTI137030.base = (&NTI147);
NTI137030.flags = 3;
TMP309[1].kind = 1;
TMP309[1].offset = offsetof(romobj137027, Header);
TMP309[1].typ = (&NTI137030);
TMP309[1].name = "header";
TMP311[1] = &TMP309[2];
TMP309[2].kind = 1;
TMP309[2].offset = offsetof(romobj137027, Prgbytes);
TMP309[2].typ = (&NTI131128);
TMP309[2].name = "prgBytes";
TMP311[2] = &TMP309[3];
TMP309[3].kind = 1;
TMP309[3].offset = offsetof(romobj137027, Chrbytes);
TMP309[3].typ = (&NTI131128);
TMP309[3].name = "chrBytes";
TMP309[0].len = 3; TMP309[0].kind = 2; TMP309[0].sons = &TMP311[0];
NTI137027.node = &TMP309[0];
NTI137029.size = sizeof(headerobj137029);
NTI137029.kind = 17;
NTI137029.base = (&NTI3211);
TMP315[0] = &TMP309[5];
TMP309[5].kind = 1;
TMP309[5].offset = offsetof(headerobj137029, Signature);
TMP309[5].typ = (&NTI149);
TMP309[5].name = "signature";
TMP315[1] = &TMP309[6];
TMP309[6].kind = 1;
TMP309[6].offset = offsetof(headerobj137029, Prgsize);
TMP309[6].typ = (&NTI108);
TMP309[6].name = "prgSize";
TMP315[2] = &TMP309[7];
TMP309[7].kind = 1;
TMP309[7].offset = offsetof(headerobj137029, Chrsize);
TMP309[7].typ = (&NTI108);
TMP309[7].name = "chrSize";
TMP315[3] = &TMP309[8];
TMP309[8].kind = 1;
TMP309[8].offset = offsetof(headerobj137029, Mmbyte);
TMP309[8].typ = (&NTI3205);
TMP309[8].name = "mmByte";
TMP315[4] = &TMP309[9];
TMP309[9].kind = 1;
TMP309[9].offset = offsetof(headerobj137029, Mapperbits);
TMP309[9].typ = (&NTI108);
TMP309[9].name = "mapperBits";
TMP315[5] = &TMP309[10];
TMP309[10].kind = 1;
TMP309[10].offset = offsetof(headerobj137029, Mirrorbits);
TMP309[10].typ = (&NTI108);
TMP309[10].name = "mirrorBits";
TMP309[4].len = 6; TMP309[4].kind = 2; TMP309[4].sons = &TMP315[0];
NTI137029.node = &TMP309[4];
}

