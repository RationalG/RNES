/* Generated by Nimrod Compiler v0.9.6 */
/*   (c) 2014 Andreas Rumpf */
/* The generated code is subject to the original license. */
/* Compiled for: Windows, amd64, gcc */
/* Command for C compiler:
   gcc.exe -c  -w  -IC:\Nimrod\lib -o c:\users\simon\rationalnes_\nimcache\queues.o c:\users\simon\rationalnes_\nimcache\queues.c */
#define NIM_INTBITS 64
#include "nimbase.h"

#include <string.h>
typedef struct tqueue207012 tqueue207012;
typedef struct TY206048 TY206048;
typedef struct TGenericSeq TGenericSeq;
typedef struct NimStringDesc NimStringDesc;
typedef struct TNimType TNimType;
typedef struct TNimNode TNimNode;
struct  TGenericSeq  {
NI len;
NI reserved;
};
struct  tqueue207012  {
TY206048* Data;
NI Rd;
NI Wr;
NI Count;
NI Mask;
};
struct  NimStringDesc  {
  TGenericSeq Sup;
NIM_CHAR data[SEQ_DECL_SIZE];
};
typedef N_NIMCALL_PTR(void, TY2689) (void* p, NI op);
typedef N_NIMCALL_PTR(void*, TY2694) (void* p);
struct  TNimType  {
NI size;
NU8 kind;
NU8 flags;
TNimType* base;
TNimNode* node;
void* finalizer;
TY2689 marker;
TY2694 deepcopy;
};
struct  TNimNode  {
NU8 kind;
NI offset;
TNimType* typ;
NCSTRING name;
NI len;
TNimNode** sons;
};
struct TY206048 {
  TGenericSeq Sup;
  NI data[SEQ_DECL_SIZE];
};
N_NIMCALL(NIM_BOOL, ispoweroftwo_193318)(NI x);
N_NIMCALL(void, failedassertimpl_85825)(NimStringDesc* msg);
static N_INLINE(NI, subInt)(NI a, NI b);
N_NOINLINE(void, raiseOverflow)(void);
N_NIMCALL(void*, newSeq)(TNimType* typ, NI len);
N_NIMCALL(void, unsureAsgnRef)(void** dest, void* src);
static N_INLINE(void, nimFrame)(TFrame* s);
N_NOINLINE(void, stackoverflow_17801)(void);
static N_INLINE(void, popFrame)(void);
static N_INLINE(NI, addInt)(NI a, NI b);
N_NIMCALL(NI, mulInt)(NI a, NI b);
N_NIMCALL(void, genericShallowAssign)(void* dest, void* src, TNimType* mt);
N_NOINLINE(void, raiseIndexError)(void);
N_NIMCALL(NimStringDesc*, copyString)(NimStringDesc* src);
static N_INLINE(void, appendString)(NimStringDesc* dest, NimStringDesc* src);
N_NIMCALL(NimStringDesc*, resizeString)(NimStringDesc* dest, NI addlen);
N_NIMCALL(NimStringDesc*, nimIntToStr)(NI x);
STRING_LITERAL(TMP483, "isPowerOfTwo(initialSize) ", 26);
STRING_LITERAL(TMP520, "[", 1);
STRING_LITERAL(TMP521, ", ", 2);
STRING_LITERAL(TMP523, "]", 1);
extern TNimType NTI206048; /* seq[int] */
extern TFrame* frameptr_15242;
TNimType NTI207012; /* TQueue */
extern TNimType NTI116; /* int */

static N_INLINE(NI, subInt)(NI a, NI b) {
	NI result;
	result = 0;
	result = (NI)((NU64)(a) - (NU64)(b));
	{
		NIM_BOOL LOC3;
		LOC3 = 0;
		LOC3 = (0 <= (NI)(result ^ a));
		if (LOC3) goto LA4;
		LOC3 = (0 <= (NI)(result ^ (NI)((NU64) ~(b))));
		LA4: ;
		if (!LOC3) goto LA5;
		goto BeforeRet;
	}
	LA5: ;
	raiseOverflow();
	BeforeRet: ;
	return result;
}

static N_INLINE(void, nimFrame)(TFrame* s) {
	NI LOC1;
	LOC1 = 0;
	{
		if (!(frameptr_15242 == NIM_NIL)) goto LA4;
		LOC1 = 0;
	}
	goto LA2;
	LA4: ;
	{
		LOC1 = ((NI) ((NI16)((*frameptr_15242).calldepth + ((NI16) 1))));
	}
	LA2: ;
	(*s).calldepth = ((NI16) (LOC1));
	(*s).prev = frameptr_15242;
	frameptr_15242 = s;
	{
		if (!((*s).calldepth == ((NI16) 2000))) goto LA9;
		stackoverflow_17801();
	}
	LA9: ;
}

static N_INLINE(void, popFrame)(void) {
	frameptr_15242 = (*frameptr_15242).prev;
}

N_NIMCALL(void, initqueue_209440)(NI initialsize_209444, tqueue207012* Result) {
	NI TMP484;
	nimfr("initQueue", "queues.nim")
	nimln(21, "queues.nim");
	{
		NIM_BOOL LOC3;
		nimln(21, "queues.nim");
		nimln(21, "queues.nim");
		LOC3 = 0;
		LOC3 = ispoweroftwo_193318(initialsize_209444);
		if (!!(LOC3)) goto LA4;
		nimln(21, "queues.nim");
		failedassertimpl_85825(((NimStringDesc*) &TMP483));
	}
	LA4: ;
	nimln(22, "queues.nim");
	nimln(22, "queues.nim");
	TMP484 = subInt(initialsize_209444, 1);
	(*Result).Mask = (NI64)(TMP484);
	nimln(23, "queues.nim");
	unsureAsgnRef((void**) &(*Result).Data, (TY206048*) newSeq((&NTI206048), initialsize_209444));
	popFrame();
}

static N_INLINE(NI, addInt)(NI a, NI b) {
	NI result;
	result = 0;
	result = (NI)((NU64)(a) + (NU64)(b));
	{
		NIM_BOOL LOC3;
		LOC3 = 0;
		LOC3 = (0 <= (NI)(result ^ a));
		if (LOC3) goto LA4;
		LOC3 = (0 <= (NI)(result ^ b));
		LA4: ;
		if (!LOC3) goto LA5;
		goto BeforeRet;
	}
	LA5: ;
	raiseOverflow();
	BeforeRet: ;
	return result;
}

N_NIMCALL(void, add_209624)(tqueue207012* q_209632, NI item_209636) {
	NI cap;
	NI TMP485;
	NI TMP491;
	nimfr("add", "queues.nim")
	nimln(40, "queues.nim");
	nimln(40, "queues.nim");
	TMP485 = addInt((*q_209632).Mask, 1);
	cap = (NI64)(TMP485);
	nimln(41, "queues.nim");
	{
		TY206048* n;
		NI TMP486;
		NI i_209656;
		NI TMP489;
		NI TMP490;
		nimln(41, "queues.nim");
		if (!(cap <= (*q_209632).Count)) goto LA3;
		n = 0;
		nimln(43, "queues.nim");
		nimln(43, "queues.nim");
		TMP486 = mulInt(cap, 2);
		n = (TY206048*) newSeq((&NTI206048), (NI64)(TMP486));
		nimln(44, "queues.nim");
		i_209656 = 0;
		{
			NI x_209693;
			tqueue207012 HEX3Atmp_209720;
			NI i_209723;
			NI c_209725;
			x_209693 = 0;
			memset((void*)&HEX3Atmp_209720, 0, sizeof(HEX3Atmp_209720));
			nimln(45, "queues.nim");
			genericShallowAssign((void*)&HEX3Atmp_209720, (void*)&(*q_209632), (&NTI207012));
			nimln(31, "queues.nim");
			i_209723 = HEX3Atmp_209720.Rd;
			nimln(32, "queues.nim");
			c_209725 = HEX3Atmp_209720.Count;
			{
				nimln(33, "queues.nim");
				while (1) {
					NI TMP488;
					nimln(33, "queues.nim");
					if (!(0 < c_209725)) goto LA7;
					nimln(34, "queues.nim");
					c_209725 = subInt(c_209725, 1);
					nimln(35, "queues.nim");
					if ((NU)(i_209723) >= (NU)(HEX3Atmp_209720.Data->Sup.len)) raiseIndexError();
					x_209693 = HEX3Atmp_209720.Data->data[i_209723];
					nimln(46, "queues.nim");
					if ((NU)(i_209656) >= (NU)(n->Sup.len)) raiseIndexError();
					n->data[i_209656] = x_209693;
					nimln(47, "queues.nim");
					i_209656 = addInt(i_209656, 1);
					nimln(36, "queues.nim");
					nimln(36, "queues.nim");
					nimln(36, "queues.nim");
					TMP488 = addInt(i_209723, 1);
					i_209723 = (NI)((NI64)(TMP488) & HEX3Atmp_209720.Mask);
				} LA7: ;
			}
		}
		nimln(48, "queues.nim");
		unsureAsgnRef((void**) &(*q_209632).Data, n);
		nimln(49, "queues.nim");
		nimln(49, "queues.nim");
		nimln(49, "queues.nim");
		TMP489 = mulInt(cap, 2);
		TMP490 = subInt((NI64)(TMP489), 1);
		(*q_209632).Mask = (NI64)(TMP490);
		nimln(50, "queues.nim");
		(*q_209632).Wr = (*q_209632).Count;
		nimln(51, "queues.nim");
		(*q_209632).Rd = 0;
	}
	LA3: ;
	nimln(52, "queues.nim");
	(*q_209632).Count = addInt((*q_209632).Count, 1);
	nimln(53, "queues.nim");
	if ((NU)((*q_209632).Wr) >= (NU)((*q_209632).Data->Sup.len)) raiseIndexError();
	(*q_209632).Data->data[(*q_209632).Wr] = item_209636;
	nimln(54, "queues.nim");
	nimln(54, "queues.nim");
	nimln(54, "queues.nim");
	TMP491 = addInt((*q_209632).Wr, 1);
	(*q_209632).Wr = (NI)((NI64)(TMP491) & (*q_209632).Mask);
	popFrame();
}

static N_INLINE(void, appendString)(NimStringDesc* dest, NimStringDesc* src) {
	memcpy(((NCSTRING) (&(*dest).data[((*dest).Sup.len)- 0])), ((NCSTRING) ((*src).data)), (NI64)((*src).Sup.len + 1));
	(*dest).Sup.len += (*src).Sup.len;
}

N_NIMCALL(NimStringDesc*, HEX24_209821)(tqueue207012* q_209827) {
	NimStringDesc* result;
	nimfr("$", "queues.nim")
	result = 0;
	nimln(69, "queues.nim");
	result = copyString(((NimStringDesc*) &TMP520));
	{
		NI x_209841;
		NI i_209846;
		NI c_209848;
		x_209841 = 0;
		nimln(31, "queues.nim");
		i_209846 = (*q_209827).Rd;
		nimln(32, "queues.nim");
		c_209848 = (*q_209827).Count;
		{
			nimln(33, "queues.nim");
			while (1) {
				NimStringDesc* LOC8;
				NI TMP522;
				nimln(33, "queues.nim");
				if (!(0 < c_209848)) goto LA3;
				nimln(34, "queues.nim");
				c_209848 = subInt(c_209848, 1);
				nimln(35, "queues.nim");
				if ((NU)(i_209846) >= (NU)((*q_209827).Data->Sup.len)) raiseIndexError();
				x_209841 = (*q_209827).Data->data[i_209846];
				nimln(71, "queues.nim");
				{
					nimln(71, "queues.nim");
					nimln(71, "queues.nim");
					if (!(1 < result->Sup.len)) goto LA6;
					nimln(71, "queues.nim");
					result = resizeString(result, 2);
appendString(result, ((NimStringDesc*) &TMP521));
				}
				LA6: ;
				nimln(72, "queues.nim");
				nimln(72, "queues.nim");
				LOC8 = 0;
				LOC8 = nimIntToStr(x_209841);
				result = resizeString(result, LOC8->Sup.len + 0);
appendString(result, LOC8);
				nimln(36, "queues.nim");
				nimln(36, "queues.nim");
				nimln(36, "queues.nim");
				TMP522 = addInt(i_209846, 1);
				i_209846 = (NI)((NI64)(TMP522) & (*q_209827).Mask);
			} LA3: ;
		}
	}
	nimln(73, "queues.nim");
	result = resizeString(result, 1);
appendString(result, ((NimStringDesc*) &TMP523));
	popFrame();
	return result;
}
N_NOINLINE(void, HEX00_queuesInit)(void) {
	nimfr("queues", "queues.nim")
	popFrame();
}

N_NOINLINE(void, HEX00_queuesDatInit)(void) {
static TNimNode* TMP487[5];
static TNimNode TMP328[6];
NTI207012.size = sizeof(tqueue207012);
NTI207012.kind = 18;
NTI207012.base = 0;
NTI207012.flags = 2;
TMP487[0] = &TMP328[1];
TMP328[1].kind = 1;
TMP328[1].offset = offsetof(tqueue207012, Data);
TMP328[1].typ = (&NTI206048);
TMP328[1].name = "data";
TMP487[1] = &TMP328[2];
TMP328[2].kind = 1;
TMP328[2].offset = offsetof(tqueue207012, Rd);
TMP328[2].typ = (&NTI116);
TMP328[2].name = "rd";
TMP487[2] = &TMP328[3];
TMP328[3].kind = 1;
TMP328[3].offset = offsetof(tqueue207012, Wr);
TMP328[3].typ = (&NTI116);
TMP328[3].name = "wr";
TMP487[3] = &TMP328[4];
TMP328[4].kind = 1;
TMP328[4].offset = offsetof(tqueue207012, Count);
TMP328[4].typ = (&NTI116);
TMP328[4].name = "count";
TMP487[4] = &TMP328[5];
TMP328[5].kind = 1;
TMP328[5].offset = offsetof(tqueue207012, Mask);
TMP328[5].typ = (&NTI116);
TMP328[5].name = "mask";
TMP328[0].len = 5; TMP328[0].kind = 2; TMP328[0].sons = &TMP487[0];
NTI207012.node = &TMP328[0];
}

