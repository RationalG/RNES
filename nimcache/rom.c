/* Generated by Nimrod Compiler v0.9.6 */
/*   (c) 2014 Andreas Rumpf */
/* The generated code is subject to the original license. */
/* Compiled for: Windows, amd64, gcc */
/* Command for C compiler:
   gcc.exe -c  -w  -IC:\Nimrod\lib -o c:\users\simon\rationalnes_\nimcache\rom.o c:\users\simon\rationalnes_\nimcache\rom.c */
#define NIM_INTBITS 64
#include "nimbase.h"

#include <string.h>

#include <stdio.h>
typedef struct trom205024 trom205024;
typedef struct TNimObject TNimObject;
typedef struct TNimType TNimType;
typedef struct TNimNode TNimNode;
typedef struct TY129110 TY129110;
typedef struct TGenericSeq TGenericSeq;
typedef struct tslice85058 tslice85058;
typedef struct theader205026 theader205026;
typedef struct NimStringDesc NimStringDesc;
typedef N_NIMCALL_PTR(void, TY2689) (void* p, NI op);
typedef N_NIMCALL_PTR(void*, TY2694) (void* p);
struct  TNimType  {
NI size;
NU8 kind;
NU8 flags;
TNimType* base;
TNimNode* node;
void* finalizer;
TY2689 marker;
TY2694 deepcopy;
};
struct  TNimObject  {
TNimType* m_type;
};
typedef NIM_CHAR TY205027[16];
struct  TGenericSeq  {
NI len;
NI reserved;
};
struct  trom205024  {
  TNimObject Sup;
TY205027 Header;
TY129110* Prgbytes;
TY129110* Chrbytes;
};
struct  TNimNode  {
NU8 kind;
NI offset;
TNimType* typ;
NCSTRING name;
NI len;
TNimNode** sons;
};
struct  tslice85058  {
NI A;
NI B;
};
struct  NimStringDesc  {
  TGenericSeq Sup;
NIM_CHAR data[SEQ_DECL_SIZE];
};
struct  theader205026  {
  TNimObject Sup;
NimStringDesc* Signature;
NI Prgsize;
NI Chrsize;
NU8 Mmbyte;
NI Mapperbits;
NI Mirrorbits;
};
struct TY129110 {
  TGenericSeq Sup;
  NIM_CHAR data[SEQ_DECL_SIZE];
};
N_NIMCALL(TY129110*, HEX5BHEX5D_205069)(TY205027 a_205076, tslice85058 x_205081);
N_NIMCALL(void, loadines_205048)(FILE* romfile, trom205024* Result);
N_NIMCALL(NI, readbuffer_12227)(FILE* f, void* buffer, NI len);
N_NIMCALL(NimStringDesc*, seqtostring_129277)(TY129110* seq);
static N_INLINE(tslice85058, HEX2EHEX2E_91890)(NI a_91894, NI b_91896);
static N_INLINE(void, nimFrame)(TFrame* s);
N_NOINLINE(void, stackoverflow_17801)(void);
static N_INLINE(void, popFrame)(void);
N_NIMCALL(NI, mulInt)(NI a, NI b);
N_NIMCALL(NimStringDesc*, nimIntToStr)(NI x);
N_NIMCALL(TY129110*, newseq_129105)(NI len_129109);
N_NOINLINE(void, raiseIndexError)(void);
N_NIMCALL(void, genericAssign)(void* dest, void* src, TNimType* mt);
STRING_LITERAL(TMP356, "iNES format recognized !!!", 26);
STRING_LITERAL(TMP357, "PRG size : ", 11);
STRING_LITERAL(TMP358, " x 16kb pages : ", 16);
STRING_LITERAL(TMP359, "CHR size : ", 11);
STRING_LITERAL(TMP360, " x 8kb pages :  ", 16);
STRING_LITERAL(TMP361, "Error : unknown ROM format :(", 29);
trom205024 nesrom_205043;
extern TNimType NTI2811; /* TObject */
TNimType NTI205024; /* TROM */
extern TNimType NTI159; /* char */
TNimType NTI205027; /* array[0..15, char] */
extern TNimType NTI129110; /* seq[char] */
TNimType NTI205026; /* THEADER */
extern TNimType NTI161; /* string */
extern TNimType NTI116; /* int */
extern TNimType NTI2805; /* Byte */
extern TFrame* frameptr_15242;

static N_INLINE(void, nimFrame)(TFrame* s) {
	NI LOC1;
	LOC1 = 0;
	{
		if (!(frameptr_15242 == NIM_NIL)) goto LA4;
		LOC1 = 0;
	}
	goto LA2;
	LA4: ;
	{
		LOC1 = ((NI) ((NI16)((*frameptr_15242).calldepth + ((NI16) 1))));
	}
	LA2: ;
	(*s).calldepth = ((NI16) (LOC1));
	(*s).prev = frameptr_15242;
	frameptr_15242 = s;
	{
		if (!((*s).calldepth == ((NI16) 2000))) goto LA9;
		stackoverflow_17801();
	}
	LA9: ;
}

static N_INLINE(void, popFrame)(void) {
	frameptr_15242 = (*frameptr_15242).prev;
}

static N_INLINE(tslice85058, HEX2EHEX2E_91890)(NI a_91894, NI b_91896) {
	tslice85058 result;
	nimfr("..", "system.nim")
	memset((void*)&result, 0, sizeof(result));
	nimln(213, "system.nim");
	result.A = a_91894;
	nimln(214, "system.nim");
	result.B = b_91896;
	popFrame();
	return result;
}

N_NIMCALL(void, loadines_205048)(FILE* romfile, trom205024* Result) {
	trom205024 r;
	theader205026 h;
	NI LOC1;
	tslice85058 LOC2;
	TY129110* LOC3;
	NI TMP354;
	NI TMP355;
	NI LOC14;
	NI LOC15;
	nimfr("loadINes", "rom.nim")
	memset((void*)&r, 0, sizeof(r));
	r.Sup.m_type = (&NTI205024);
	memset((void*)&h, 0, sizeof(h));
	h.Sup.m_type = (&NTI205026);
	nimln(30, "rom.nim");
	nimln(30, "rom.nim");
	LOC1 = 0;
	LOC1 = readbuffer_12227(romfile, ((void*) (r.Header)), 16);
	nimln(32, "rom.nim");
	nimln(32, "rom.nim");
	nimln(32, "rom.nim");
	LOC2 = HEX2EHEX2E_91890(0, 3);
	LOC3 = 0;
	LOC3 = HEX5BHEX5D_205069(r.Header, LOC2);
	h.Signature = seqtostring_129277(LOC3);
	nimln(33, "rom.nim");
	nimln(33, "rom.nim");
	TMP354 = mulInt(((NI) (((NU8)(r.Header[(4)- 0])))), 16384);
	h.Prgsize = (NI64)(TMP354);
	nimln(34, "rom.nim");
	nimln(34, "rom.nim");
	TMP355 = mulInt(((NI) (((NU8)(r.Header[(5)- 0])))), 8192);
	h.Chrsize = (NI64)(TMP355);
	nimln(35, "rom.nim");
	h.Mmbyte = ((NU8) (((NU8)(r.Header[(6)- 0]))));
	nimln(36, "rom.nim");
	nimln(36, "rom.nim");
	nimln(36, "rom.nim");
	h.Mapperbits = ((NI) ((NI)((NI)((NU64)(((NI) (h.Mmbyte))) >> (NU64)(4)) & 15)));
	nimln(37, "rom.nim");
	nimln(37, "rom.nim");
	h.Mirrorbits = ((NI) ((NI)(((NI) (h.Mmbyte)) & 15)));
	nimln(39, "rom.nim");
	{
		int LOC6;
		NimStringDesc* LOC9;
		NimStringDesc* LOC10;
		NimStringDesc* LOC11;
		NimStringDesc* LOC12;
		nimln(39, "rom.nim");
		nimln(39, "rom.nim");
		LOC6 = 0;
		LOC6 = memcmp(h.Signature->data, "NES\032", 4);
		if (!(LOC6 == ((NI32) 0))) goto LA7;
		nimln(40, "rom.nim");
		printf("%s\015\012", (((NimStringDesc*) &TMP356))->data);
		nimln(41, "rom.nim");
		nimln(41, "rom.nim");
		nimln(41, "rom.nim");
		LOC9 = 0;
		LOC9 = nimIntToStr((NI)((NU64)(h.Prgsize) / (NU64)(16384)));
		nimln(41, "rom.nim");
		LOC10 = 0;
		LOC10 = nimIntToStr(h.Prgsize);
		printf("%s%s%s%s\015\012", (((NimStringDesc*) &TMP357))->data, (LOC9)->data, (((NimStringDesc*) &TMP358))->data, (LOC10)->data);
		nimln(42, "rom.nim");
		nimln(42, "rom.nim");
		nimln(42, "rom.nim");
		LOC11 = 0;
		LOC11 = nimIntToStr((NI)((NU64)(h.Chrsize) / (NU64)(8192)));
		nimln(42, "rom.nim");
		LOC12 = 0;
		LOC12 = nimIntToStr(h.Chrsize);
		printf("%s%s%s%s\015\012", (((NimStringDesc*) &TMP359))->data, (LOC11)->data, (((NimStringDesc*) &TMP360))->data, (LOC12)->data);
	}
	goto LA4;
	LA7: ;
	{
		nimln(44, "rom.nim");
		printf("%s\015\012", (((NimStringDesc*) &TMP361))->data);
		nimln(45, "rom.nim");
		goto BeforeRet;
	}
	LA4: ;
	nimln(47, "rom.nim");
	r.Prgbytes = newseq_129105(h.Prgsize);
	nimln(48, "rom.nim");
	r.Chrbytes = newseq_129105(h.Chrsize);
	nimln(50, "rom.nim");
	nimln(50, "rom.nim");
	if ((NU)(0) >= (NU)(r.Prgbytes->Sup.len)) raiseIndexError();
	LOC14 = 0;
	LOC14 = readbuffer_12227(romfile, ((void*) (&r.Prgbytes->data[0])), h.Prgsize);
	nimln(51, "rom.nim");
	nimln(51, "rom.nim");
	if ((NU)(0) >= (NU)(r.Chrbytes->Sup.len)) raiseIndexError();
	LOC15 = 0;
	LOC15 = readbuffer_12227(romfile, ((void*) (&r.Chrbytes->data[0])), h.Chrsize);
	nimln(53, "rom.nim");
	nimln(53, "rom.nim");
	genericAssign((void*)Result, (void*)&r, (&NTI205024));
	goto BeforeRet;
	BeforeRet: ;
	popFrame();
}
N_NOINLINE(void, HEX00_romInit)(void) {
	nimfr("rom", "rom.nim")
	nesrom_205043.Sup.m_type = (&NTI205024);
	popFrame();
}

N_NOINLINE(void, HEX00_romDatInit)(void) {
static TNimNode* TMP349[3];
static TNimNode* TMP353[6];
static TNimNode TMP347[11];
NTI205024.size = sizeof(trom205024);
NTI205024.kind = 17;
NTI205024.base = (&NTI2811);
TMP349[0] = &TMP347[1];
NTI205027.size = sizeof(TY205027);
NTI205027.kind = 16;
NTI205027.base = (&NTI159);
NTI205027.flags = 3;
TMP347[1].kind = 1;
TMP347[1].offset = offsetof(trom205024, Header);
TMP347[1].typ = (&NTI205027);
TMP347[1].name = "header";
TMP349[1] = &TMP347[2];
TMP347[2].kind = 1;
TMP347[2].offset = offsetof(trom205024, Prgbytes);
TMP347[2].typ = (&NTI129110);
TMP347[2].name = "prgBytes";
TMP349[2] = &TMP347[3];
TMP347[3].kind = 1;
TMP347[3].offset = offsetof(trom205024, Chrbytes);
TMP347[3].typ = (&NTI129110);
TMP347[3].name = "chrBytes";
TMP347[0].len = 3; TMP347[0].kind = 2; TMP347[0].sons = &TMP349[0];
NTI205024.node = &TMP347[0];
NTI205026.size = sizeof(theader205026);
NTI205026.kind = 17;
NTI205026.base = (&NTI2811);
TMP353[0] = &TMP347[5];
TMP347[5].kind = 1;
TMP347[5].offset = offsetof(theader205026, Signature);
TMP347[5].typ = (&NTI161);
TMP347[5].name = "signature";
TMP353[1] = &TMP347[6];
TMP347[6].kind = 1;
TMP347[6].offset = offsetof(theader205026, Prgsize);
TMP347[6].typ = (&NTI116);
TMP347[6].name = "prgSize";
TMP353[2] = &TMP347[7];
TMP347[7].kind = 1;
TMP347[7].offset = offsetof(theader205026, Chrsize);
TMP347[7].typ = (&NTI116);
TMP347[7].name = "chrSize";
TMP353[3] = &TMP347[8];
TMP347[8].kind = 1;
TMP347[8].offset = offsetof(theader205026, Mmbyte);
TMP347[8].typ = (&NTI2805);
TMP347[8].name = "mmByte";
TMP353[4] = &TMP347[9];
TMP347[9].kind = 1;
TMP347[9].offset = offsetof(theader205026, Mapperbits);
TMP347[9].typ = (&NTI116);
TMP347[9].name = "mapperBits";
TMP353[5] = &TMP347[10];
TMP347[10].kind = 1;
TMP347[10].offset = offsetof(theader205026, Mirrorbits);
TMP347[10].typ = (&NTI116);
TMP347[10].name = "mirrorBits";
TMP347[4].len = 6; TMP347[4].kind = 2; TMP347[4].sons = &TMP353[0];
NTI205026.node = &TMP347[4];
}

